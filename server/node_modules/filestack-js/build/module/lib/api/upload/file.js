import { __assign, __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { md5, sanitizeName } from './../../utils';
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
var File = /** @class */ (function () {
    function File(_file, _sanitizeOptions) {
        this._file = _file;
        this._sanitizeOptions = _sanitizeOptions;
        this._file.name = sanitizeName(this._file.name, this._sanitizeOptions);
    }
    Object.defineProperty(File.prototype, "name", {
        /**
         * Returns file name
         *
         * @returns {string}
         * @memberof File
         */
        get: function () {
            return this._file.name;
        },
        /**
         * Sets new file name  and cleanup extra chars
         *
         * @memberof File
         */
        set: function (val) {
            this._file.name = sanitizeName(val, this._sanitizeOptions);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "filename", {
        /**
         * Alias for name getter
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "customName", {
        /**
         * Sets custom name using string or function
         * Name will be sanitized
         *
         * @memberof File
         */
        set: function (val) {
            switch (typeof val) {
                case 'string':
                    this.name = val;
                    break;
                case 'function':
                    var newName = val(this);
                    if (typeof newName !== 'string') {
                        throw new Error("Name function must return a string. Current return type is ".concat(typeof val));
                    }
                    this.name = val(this);
                    break;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "type", {
        /**
         * Returns file type
         *
         * @default 'application/octet-stream'
         * @returns {string}
         * @memberof File
         */
        get: function () {
            /* istanbul ignore next */
            return this._file.type || 'application/octet-stream';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mimetype", {
        /**
         * Alias for file type
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        /**
         * Returns file size
         *
         * @returns {number}
         * @memberof File
         */
        get: function () {
            return this._file.size;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns number of parts and part size according to max limit
     * @param {number} size - part size in bytes
     * @returns {PartSize}
     * @memberof File
     */
    File.prototype.getPartsCount = function (size, intelligentChunk) {
        var DEFAULT_FILE_SIZE_LIMIT = 59 * 1024 * 1024 * 1024;
        var INTELLIGENT_FILE_SIZE_LIMIT = 79 * 1024 * 1024 * 1024;
        var FILE_SIZE_LIMIT = intelligentChunk ? INTELLIGENT_FILE_SIZE_LIMIT : DEFAULT_FILE_SIZE_LIMIT;
        var MAX_S3_CHUNKS_ALLOWED = 10000;
        // When file size is greater than 60GB, chunk size is calculated dynamically
        // Chunk count is set to the max number of chunks allowed over s3
        if (this._file.size >= FILE_SIZE_LIMIT) {
            var dynamicPartSize = Math.ceil(this._file.size / MAX_S3_CHUNKS_ALLOWED); // size is set in bytes
            return {
                partsCount: Math.ceil(this._file.size / dynamicPartSize),
                chunkSize: dynamicPartSize,
            };
        }
        return {
            partsCount: Math.ceil(this._file.size / size),
            chunkSize: size,
        };
    };
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    File.prototype.getPartMetadata = function (partNum, size) {
        var startByte = size * partNum;
        if (startByte > this._file.size) {
            throw new Error("Start byte of the part is higher than buffer size");
        }
        var endByte = Math.min(startByte + size, this._file.size);
        return {
            partNumber: partNum,
            startByte: startByte,
            endByte: endByte,
            size: endByte - startByte,
        };
    };
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getPartByMetadata = function (meta, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return __awaiter(this, void 0, void 0, function () {
            var slice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._file.slice(meta.startByte, meta.endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(__assign(__assign({}, meta), { buffer: slice, md5: md5Enabled ? md5(slice) : undefined }))];
                }
            });
        });
    };
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getChunkByMetadata = function (meta, offset, chunkSize, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return __awaiter(this, void 0, void 0, function () {
            var startByte, endByte, slice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startByte = meta.startByte + offset;
                        endByte = Math.min(startByte + chunkSize, meta.endByte);
                        return [4 /*yield*/, this._file.slice(startByte, endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(__assign(__assign({}, meta), { buffer: slice, md5: md5Enabled ? md5(slice) : undefined, size: slice.byteLength, startByte: startByte, endByte: endByte, offset: offset }))];
                }
            });
        });
    };
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    File.prototype.release = function () {
        if (this._file.release) {
            this._file.release();
        }
    };
    File.prototype.toJSON = function () {
        return {
            name: this.name,
            status: this.status,
            type: this.type,
            size: this.size,
            url: this.url,
            handle: this.handle,
            uploadTags: this.uploadTags,
        };
    };
    return File;
}());
export { File };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxPQUFPLEVBQUUsR0FBRyxFQUFFLFlBQVksRUFBbUIsTUFBTSxlQUFlLENBQUM7QUEyQ25FOzs7OztHQUtHO0FBQ0g7SUFnQkUsY0FBNkIsS0FBbUIsRUFBbUIsZ0JBQWtDO1FBQXhFLFVBQUssR0FBTCxLQUFLLENBQWM7UUFBbUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNuRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekUsQ0FBQztJQVFELHNCQUFXLHNCQUFJO1FBTmY7Ozs7O1dBS0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDekIsQ0FBQztRQWFEOzs7O1dBSUc7YUFDSCxVQUFnQixHQUFXO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDN0QsQ0FBQzs7O09BcEJBO0lBU0Qsc0JBQVcsMEJBQVE7UUFQbkI7Ozs7OztXQU1HO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsQ0FBQzs7O09BQUE7SUFpQkQsc0JBQVcsNEJBQVU7UUFOckI7Ozs7O1dBS0c7YUFDSCxVQUFzQixHQUFzQztZQUMxRCxRQUFRLE9BQU8sR0FBRyxFQUFFO2dCQUNsQixLQUFLLFFBQVE7b0JBQ1gsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7b0JBQ2hCLE1BQU07Z0JBQ1IsS0FBSyxVQUFVO29CQUNiLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUIsSUFB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LEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO1lBQ2IsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUNILFdBQUM7QUFBRCxDQWhPQSxBQWdPQyxJQUFBIiwiZmlsZSI6ImxpYi9hcGkvdXBsb2FkL2ZpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgbWQ1LCBzYW5pdGl6ZU5hbWUsIFNhbml0aXplT3B0aW9ucyB9IGZyb20gJy4vLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFRhZ3Mge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUluc3RhbmNlIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbiAgc2xpY2U6IChzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4gUHJvbWlzZTxBcnJheUJ1ZmZlcj47XG4gIHJlbGVhc2U/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBGaWxlU3RhdGUge1xuICBJTklUID0gJ0luaXRpYWxpemVkJyxcbiAgUFJPR1JFU1MgPSAnUHJvZ3Jlc3MnLFxuICBTVE9SRUQgPSAnU3RvcmVkJyxcbiAgSU5UUkFOU0lUID0gJ0luVHJhbnNpdCcsXG4gIEZBSUxFRCA9ICdGYWlsZWQnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXJ0TWV0YWRhdGEge1xuICBzdGFydEJ5dGU6IG51bWJlcjtcbiAgZW5kQnl0ZTogbnVtYmVyO1xuICBwYXJ0TnVtYmVyOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlUGFydCBleHRlbmRzIEZpbGVQYXJ0TWV0YWRhdGEge1xuICBidWZmZXI6IEJ1ZmZlciB8IEFycmF5QnVmZmVyO1xuICBtZDU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUNodW5rIGV4dGVuZHMgRmlsZVBhcnQge1xuICBvZmZzZXQ6IG51bWJlcjsgLy8gb2Zmc2V0IGZvciBjaHVuayAtIGZyb20gcGFydCBzdGFydFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRTaXplIHtcbiAgcGFydHNDb3VudDogbnVtYmVyO1xuICBjaHVua1NpemU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBGaWxlIHJlcHJlc2VudGF0aW9uIHRvIHVuaWZ5IGZpbGUgb2JqZWN0IGluIG5vZGVqcyBhbmQgYnJvd3NlclxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBGaWxlXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlIHtcblxuICBwdWJsaWMgc3RhdHVzOiBGaWxlU3RhdGU7XG5cbiAgcHVibGljIGhhbmRsZTogc3RyaW5nO1xuXG4gIHB1YmxpYyB1cmw6IHN0cmluZztcblxuICBwdWJsaWMgY29udGFpbmVyOiBzdHJpbmc7XG5cbiAgcHVibGljIGtleTogc3RyaW5nO1xuXG4gIHB1YmxpYyB3b3JrZmxvd3M6IGFueVtdO1xuXG4gIHB1YmxpYyB1cGxvYWRUYWdzOiBVcGxvYWRUYWdzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX2ZpbGU6IEZpbGVJbnN0YW5jZSwgcHJpdmF0ZSByZWFkb25seSBfc2FuaXRpemVPcHRpb25zPzogU2FuaXRpemVPcHRpb25zKSB7XG4gICAgdGhpcy5fZmlsZS5uYW1lID0gc2FuaXRpemVOYW1lKHRoaXMuX2ZpbGUubmFtZSwgdGhpcy5fc2FuaXRpemVPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbGUgbmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgbmFtZSBnZXR0ZXJcbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpbGVuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG5ldyBmaWxlIG5hbWUgIGFuZCBjbGVhbnVwIGV4dHJhIGNoYXJzXG4gICAqXG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgc2V0IG5hbWUodmFsOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9maWxlLm5hbWUgPSBzYW5pdGl6ZU5hbWUodmFsLCB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY3VzdG9tIG5hbWUgdXNpbmcgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gICAqIE5hbWUgd2lsbCBiZSBzYW5pdGl6ZWRcbiAgICpcbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBzZXQgY3VzdG9tTmFtZSh2YWw6ICgoZmlsZTogdGhpcykgPT4gc3RyaW5nKSB8IHN0cmluZykge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgY29uc3QgbmV3TmFtZSA9IHZhbCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy4gQ3VycmVudCByZXR1cm4gdHlwZSBpcyAke3R5cGVvZiB2YWx9YCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hbWUgPSB2YWwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbGUgdHlwZVxuICAgKlxuICAgKiBAZGVmYXVsdCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy5fZmlsZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBmaWxlIHR5cGVcbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1pbWV0eXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbGUgc2l6ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBwYXJ0cyBhbmQgcGFydCBzaXplIGFjY29yZGluZyB0byBtYXggbGltaXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBwYXJ0IHNpemUgaW4gYnl0ZXNcbiAgICogQHJldHVybnMge1BhcnRTaXplfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldFBhcnRzQ291bnQgKHNpemU6IG51bWJlciwgaW50ZWxsaWdlbnRDaHVuazogYm9vbGVhbik6IFBhcnRTaXplIHtcbiAgICBjb25zdCBERUZBVUxUX0ZJTEVfU0laRV9MSU1JVCA9IDU5ICogMTAyNCAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IElOVEVMTElHRU5UX0ZJTEVfU0laRV9MSU1JVCA9IDc5ICogMTAyNCAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IEZJTEVfU0laRV9MSU1JVCA9IGludGVsbGlnZW50Q2h1bmsgPyBJTlRFTExJR0VOVF9GSUxFX1NJWkVfTElNSVQgOiBERUZBVUxUX0ZJTEVfU0laRV9MSU1JVDtcbiAgICBjb25zdCBNQVhfUzNfQ0hVTktTX0FMTE9XRUQgPSAxMDAwMDtcblxuICAgIC8vIFdoZW4gZmlsZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiA2MEdCLCBjaHVuayBzaXplIGlzIGNhbGN1bGF0ZWQgZHluYW1pY2FsbHlcbiAgICAvLyBDaHVuayBjb3VudCBpcyBzZXQgdG8gdGhlIG1heCBudW1iZXIgb2YgY2h1bmtzIGFsbG93ZWQgb3ZlciBzM1xuICAgIGlmICh0aGlzLl9maWxlLnNpemUgPj0gRklMRV9TSVpFX0xJTUlUKSB7XG4gICAgICBjb25zdCBkeW5hbWljUGFydFNpemUgPSBNYXRoLmNlaWwodGhpcy5fZmlsZS5zaXplIC8gTUFYX1MzX0NIVU5LU19BTExPV0VEKTsgLy8gc2l6ZSBpcyBzZXQgaW4gYnl0ZXNcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydHNDb3VudDogTWF0aC5jZWlsKHRoaXMuX2ZpbGUuc2l6ZSAvIGR5bmFtaWNQYXJ0U2l6ZSksXG4gICAgICAgIGNodW5rU2l6ZTogZHluYW1pY1BhcnRTaXplLFxuICAgICAgfTtcblxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJ0c0NvdW50OiBNYXRoLmNlaWwodGhpcy5fZmlsZS5zaXplIC8gc2l6ZSksXG4gICAgICBjaHVua1NpemU6IHNpemUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgbWV0YWRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJ0TnVtPTBdXG4gICAqIEBwYXJhbSB7Kn0gc2l6ZVxuICAgKiBAcmV0dXJucyB7RmlsZVBhcnRNZXRhZGF0YX1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXRQYXJ0TWV0YWRhdGEgKHBhcnROdW06IG51bWJlciwgc2l6ZTogbnVtYmVyKTogRmlsZVBhcnRNZXRhZGF0YSB7XG4gICAgY29uc3Qgc3RhcnRCeXRlID0gc2l6ZSAqIHBhcnROdW07XG5cbiAgICBpZiAoc3RhcnRCeXRlID4gdGhpcy5fZmlsZS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXJ0IGJ5dGUgb2YgdGhlIHBhcnQgaXMgaGlnaGVyIHRoYW4gYnVmZmVyIHNpemVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRCeXRlID0gTWF0aC5taW4oc3RhcnRCeXRlICsgc2l6ZSwgdGhpcy5fZmlsZS5zaXplKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXJ0TnVtYmVyOiBwYXJ0TnVtLFxuICAgICAgc3RhcnRCeXRlLFxuICAgICAgZW5kQnl0ZSxcbiAgICAgIHNpemU6IGVuZEJ5dGUgLSBzdGFydEJ5dGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgbWV0YWRhdGEgKyBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlUGFydE1ldGFkYXRhfSBtZXRhXG4gICAqIEByZXR1cm5zIHtGaWxlUGFydH1cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRQYXJ0QnlNZXRhZGF0YShtZXRhOiBGaWxlUGFydE1ldGFkYXRhLCBtZDVFbmFibGVkOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8RmlsZVBhcnQ+IHtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLl9maWxlLnNsaWNlKG1ldGEuc3RhcnRCeXRlLCBtZXRhLmVuZEJ5dGUpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi5tZXRhLFxuICAgICAgYnVmZmVyOiBzbGljZSxcbiAgICAgIG1kNTogbWQ1RW5hYmxlZCA/IG1kNShzbGljZSkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwYXJ0IGNodW5rXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZVBhcnRNZXRhZGF0YX0gbWV0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemVcbiAgICogQHJldHVybnMge0ZpbGVQYXJ0fVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldENodW5rQnlNZXRhZGF0YShtZXRhOiBGaWxlUGFydE1ldGFkYXRhLCBvZmZzZXQ6IG51bWJlciwgY2h1bmtTaXplOiBudW1iZXIsIG1kNUVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxGaWxlQ2h1bms+IHtcbiAgICBjb25zdCBzdGFydEJ5dGUgPSBtZXRhLnN0YXJ0Qnl0ZSArIG9mZnNldDtcbiAgICBjb25zdCBlbmRCeXRlID0gTWF0aC5taW4oc3RhcnRCeXRlICsgY2h1bmtTaXplLCBtZXRhLmVuZEJ5dGUpO1xuXG4gICAgbGV0IHNsaWNlID0gYXdhaXQgdGhpcy5fZmlsZS5zbGljZShzdGFydEJ5dGUsIGVuZEJ5dGUpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi5tZXRhLFxuICAgICAgYnVmZmVyOiBzbGljZSxcbiAgICAgIG1kNTogbWQ1RW5hYmxlZCA/IG1kNShzbGljZSkgOiB1bmRlZmluZWQsXG4gICAgICBzaXplOiBzbGljZS5ieXRlTGVuZ3RoLFxuICAgICAgc3RhcnRCeXRlLFxuICAgICAgZW5kQnl0ZSxcbiAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW51cCBmaWxlIGJ1ZmZlciB0byByZWxlYXNlIG1lbW9yeVxuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIHJlbGVhc2UoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbGUucmVsZWFzZSkge1xuICAgICAgdGhpcy5fZmlsZS5yZWxlYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoYW5kbGU6IHRoaXMuaGFuZGxlLFxuICAgICAgdXBsb2FkVGFnczogdGhpcy51cGxvYWRUYWdzLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==
